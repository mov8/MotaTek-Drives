import 'package:flutter/material.dart';
import 'dart:convert';
import 'dart:math';
import 'dart:developer' as developer;
import 'package:geolocator/geolocator.dart';
import 'package:http/http.dart' as http;
import 'package:latlong2/latlong.dart';
import '/classes/classes.dart';
import '/models/models.dart';
import '/constants.dart';
import '/classes/route.dart' as mt;

enum ChipRequest { none, arrow, burger, details }

Map<String, dynamic> chipRequests = {
  'ledingWidget': -1,
  'getTripDetails': false
};

List<LatLng> waypointsFromPointsOfInterest(
    {bool reversed = false,
    double newPointLat = 0.0,
    newPointLng = 0.0,
    atEnd = false}) {
  List<LatLng> waypoints = [];
  List<PointOfInterest> pois = [];
  pois.addAll(CurrentTripItem().pointsOfInterest);
  if (reversed) {
    pois = pois.reversed.toList();
  }

  if (newPointLat + newPointLng != 0) {
    if (atEnd) {
      if (pois[pois.length - 1].type == 18) {
        pois[pois.length - 1].type = 12;
      }
      pois.add(
        PointOfInterest(
          type: 18,
          point: LatLng(newPointLat, newPointLng),
        ),
      );
    } else {
      if (pois[0].type == 17) {
        pois[0].type = 12;
      }
      pois.insert(
        0,
        PointOfInterest(
          type: 17,
          point: LatLng(newPointLat, newPointLng),
        ),
      );
    }
    CurrentTripItem().pointsOfInterest = pois;
  }

  for (int i = 0; i < pois.length; i++) {
    if ([12, 17, 18, 19].contains(pois[i].type)) {
      waypoints.add(pois[i].point);
    }
  }

  return waypoints;
}

Future<String> waypointsFromManeuvers(
    {int points = 50, reverse = false}) async {
  List<LatLng> latLongs = [];

  /// Only going to add the start, end, and any turns. The Router will do the rest
  latLongs.add(CurrentTripItem().maneuvers[0].location);
  latLongs.add(CurrentTripItem()
      .maneuvers[CurrentTripItem().maneuvers.length - 1]
      .location);

  if (reverse) {
    latLongs = latLongs.reversed.toList();
    return '${latLongs[0].longitude},${latLongs[0].latitude};${latLongs[1].longitude},${latLongs[1].latitude}';
  }

  int count = latLongs.length;
  final double incrementer;
  if (count <= points) {
    incrementer = 1;
  } else {
    incrementer = count / points;
  }

  String waypoints = '';
  String delimiter = '';
  for (int i = 0; i < count; i++) {
    int idx = (incrementer * i).round();
    if (idx < latLongs.length) {
      waypoints =
          '$waypoints$delimiter${latLongs[idx].longitude},${latLongs[idx].latitude}';
      delimiter = ';';
    } else {
      debugPrint('Index overflow');
    }
  }

  return waypoints;
}

Future<String> waypointsFromPoints(int points) async {
  List<LatLng> latLongs = [];
  for (int i = 0; i < CurrentTripItem().routes.length; i++) {
    latLongs = latLongs + CurrentTripItem().routes[i].points;
  }
  int count = latLongs.length;

  if (count / points < 10) {
    points = count ~/ 10;
  }

  int gap = (count - 2) ~/ points;

  String waypoints = '${latLongs[0].longitude},${latLongs[0].latitude}';
  for (int i = 0; i < points - 2; i++) {
    int idx = gap * (i + 1);
    try {
      waypoints =
          '$waypoints;${latLongs[idx].longitude},${latLongs[idx].latitude}';
    } catch (e) {
      debugPrint('Error getting points: ${e.toString()}');
    }
  }

  waypoints =
      '$waypoints;${latLongs[count - 1].longitude},${latLongs[count - 1].latitude}';

  return waypoints;
}

addWaypointAt({required LatLng pos, bool before = false}) async {
  String name = 'End';
  int idx = CurrentTripItem().pointsOfInterest.length;
  int markerType = 18;
  if (idx == 0 || before) {
    name = 'Start';
    idx = 0;
    markerType = 17;
  }
  PointOfInterest waypoint = PointOfInterest(
    id: -1,
    driveId: CurrentTripItem().driveId,
    type: markerType,
    name: name,
    description: '',
    width: 10,
    height: 10,
    point: pos,
  );
  if (before) {
    CurrentTripItem().pointsOfInterest.insert(0, waypoint);
  } else {
    CurrentTripItem().pointsOfInterest.add(waypoint);
  }
}

String setAvoiding() {
  /// avoid = '&exclude=motorway,trunk,primary';
  /// The avoid categories are defined in OSRM/osrm-backend/car.lua
  String avoiding = '';
  if (Setup().avoidMotorways) {
    avoiding = '&exclude=motorway';
    if (Setup().avoidAroads) {
      avoiding = '&exclude=motorway,trunk,primary';
    }
  } else if (Setup().avoidAroads) {
    avoiding = '&exclude=trunk,primary';
  } else if (Setup().avoidFerries) {
    avoiding = '&exclude=ferry';
  } else if (Setup().avoidTollRoads) {
    avoiding = '&exclude=toll';
  }
  return avoiding;
}

/// For drives that have been generated by tracking there are no defined waypoints. The drive consists
/// of only the polylines, and hasn't been through the router to generate maneuvers. The challenge is to
/// provide calculated waypoints that the router can use to follow the route and generate the maneuvers.
/// Originally just used every nth point, but the number of points reflect the complexity of the route.
/// Roundabouts for example consume lots of points.
/// The next strategy is to look at the total length of the route by going through all the points, and
/// then space the calculated waypoints equidistant - with a target of around a mile apart for drives
/// < 50 miles 2 miles for drives > 50 < 100 etc. As long as the gaps aren't too great the router should
/// replicate the tracked trip. 50 points is the maximum number of points the router can take. Less than
/// 1 mile apart is unnecessary. As the points are calculated they should be removed from the maneuvers,
/// as they would constrain the drive in a way not defined by the user.
/// The user can then add any waypoints that are needed to control the route.

Future<Map<String, dynamic>> getRoutePoints(
    {required List<LatLng> points, bool addPoints = true}) async {
  dynamic jsonResponse;
  int jump = points.length > 50 ? (points.length ~/ 50) : 1;
  jump = jump > 1 && jump * 50 > points.length ? jump - 1 : jump;
  String delim = '';
  String waypoints = '';
  for (int i = 0; i < points.length; i += jump) {
    waypoints = '$waypoints$delim${points[i].longitude},${points[i].latitude}';
    delim = ';';
  }

  String avoid = setAvoiding();
  var url = Uri.parse(
      '$urlRouter$waypoints?steps=true&annotations=true&geometries=geojson&overview=full$avoid');
  try {
    var response = await http.get(url).timeout(const Duration(seconds: 5));
    if ([200, 201].contains(response.statusCode)) {
      jsonResponse = jsonDecode(response.body);
      if (jsonResponse == null) {
        return {'msg': 'Error'};
      }
    } else {
      return {'msg': 'Error'};
    }
  } catch (e) {
    debugPrint('Http error: ${e.toString()}');
    return {'msg': 'Error'};
  }
  List<LatLng> routePoints = [];
  List<Maneuver> maneuvers = [];
  final Map<String, dynamic> result = {
    "name": '',
    "distance": '0.0',
    "duration": 0,
    "summary": '',
    "maneuvers": maneuvers,
    "points": routePoints,
  };

  double distance = 0;
  double duration = 0;
  try {
    distance = jsonResponse['routes'][0]['distance'].toDouble();
    duration = jsonResponse['routes'][0]['duration'].toDouble();
    distance = distance / 1000 * 5 / 8;
  } catch (e) {
    debugPrint('Error: $e');
  }
  String summary =
      '${distance.toStringAsFixed(1)} miles - (${(duration / 60).floor()} minutes)';

  /// ToDo: handling turn by turn:
  /// ...['steps'][n]['name'] => the current road name
  /// ...['steps'][n]['maneuver'][bearing_before'] => approach bearing
  /// ...['steps'][n]['maneuver'][bearing_after] => exit bearing
  /// ...['steps'][n]['maneuver']['location'] => latLng of intersection
  /// ...['steps'][n]['maneuver']['modifier'] => 'right', 'left' etc
  /// ...['steps'][n]['maneuver']['type'] => 'turn' etc
  /// ...['steps'][n]['maneuver']['name'] => 'Alexandra Road'
  ///

  String type = '';

  if (addPoints) {
    var router = jsonResponse['routes'][0]['geometry']['coordinates'];
    for (int i = 0; i < router.length; i++) {
      routePoints.add(LatLng(router[i][1], router[i][0]));
    }
  }

  try {
    List<dynamic> legs = jsonResponse['routes'][0]['legs'];
    String lastRoad = legs[0]['steps'][0]['name'];
    String name =
        '$lastRoad - ${legs[0]['steps'][legs[0]['steps'].length - 1]['name']}';
    for (int j = 0; j < legs.length; j++) {
      List<dynamic> steps = legs[j]["steps"];
      double distance = 0;

      int bearingBefore = 0;
      int bearingAfter = 0;
      for (int k = 0; k < steps.length; k++) {
        lastRoad = steps[k]['name'] ?? '';
        Map<String, dynamic> maneuver = steps[k]['maneuver'];
        try {
          type = maneuver['type'] ?? '';
          String modifier = maneuver['modifier'] ?? '';
          if ((modifier.isNotEmpty || type == 'depart')) {
            if (modifier.isEmpty) {
              debugPrint('empty');
            }

            if (type.contains('roundabout') || type.contains('rotary')) {
              try {
                if (type.contains('exit')) {
                  bearingAfter = maneuver['bearing_after'] ?? 0;
                  modifier = bearingAfter > bearingBefore ? 'right' : 'left';
                  if ((bearingAfter - bearingBefore).abs() < 60) {
                    modifier = 'slightly $modifier';
                  }
                  //    modifier = '$modifier (${bearingAfter - bearingBefore})';
                  maneuvers[maneuvers.length - 1].modifier = modifier;
                  maneuvers[maneuvers.length - 1].bearingAfter = bearingAfter;
                } else {
                  bearingBefore = maneuver['bearing_before'] ?? 0;
                }
              } catch (e) {
                developer.log('bearing error: ${e.toString()}',
                    name: '_roundabout');
              }
            } else {
              bearingBefore = maneuver['bearing_before'] ?? 0;
              bearingAfter = maneuver['bearing_after'] ?? 0;
            }

            List<dynamic> lngLat = maneuver['location'];
            distance += steps[k]['distance'].toDouble();
            maneuvers.add(
              Maneuver(
                roadFrom: steps[k]['name'],
                roadTo: lastRoad,
                bearingBefore: bearingBefore,
                bearingAfter: bearingAfter,
                exit: maneuver['exit'] ?? 0,
                location: LatLng(lngLat[1].toDouble(), lngLat[0].toDouble()),
                modifier: modifier,
                type: type,
                distance: distance,
              ),
            );
            distance = 0;
          }
        } catch (e) {
          String err = e.toString();
          debugPrint(err);
        }
        if (maneuvers.length > 1) {
          maneuvers[maneuvers.length - 2].roadTo =
              maneuvers[maneuvers.length - 1].roadFrom;
        }
        if (maneuvers.isNotEmpty) {
          lastRoad = maneuvers[maneuvers.length - 1].roadTo;
          developer.log('lastRoad $lastRoad', name: '_roundabout');
          maneuvers[maneuvers.length - 1].type = maneuvers[maneuvers.length - 1]
              .type
              .replaceAll('rotary', 'roundabout');
        }
      }
    }
    result["name"] = name;
    result["distance"] = distance.toStringAsFixed(1);
    result["duration"] = jsonResponse['routes'][0]['duration'];
    result["summary"] = summary;
    result["maneuvers"] = maneuvers;
    result["points"] = routePoints;
  } catch (e) {
    debugPrint('Error processing router data: ${e.toString()}');
  }
  return result;
}

RouteDelta distanceFromRoute(
    {required List<mt.Route> routes,
    required LatLng position,
    RouteDelta? routeDelta,
    int trigger = 100}) {
  int distance = 200000;
  routeDelta ??= RouteDelta();
  routeDelta.point = position;
  routeDelta.distance = 200000;
  routeDelta.pointIndex = -1;
  for (int i = 0; i < routes.length; i++) {
    mt.Route route = routes[i];
    for (int j = 0; j < route.points.length; j++) {
      distance = Geolocator.distanceBetween(
              position.latitude,
              position.longitude,
              route.points[j].latitude,
              route.points[j].longitude)
          .toInt();
      if (distance < routeDelta.distance) {
        routeDelta.distance = distance;
        routeDelta.pointIndex = j;
        routeDelta.routeIndex = i;
        routeDelta.point = route.points[j];
      } else if (distance <= trigger) {
        break;
      }
    }
  }
  return routeDelta;
}

int getRoundaboutAngle(
    {required List<Maneuver> maneuvers,
    required int index,
    required List<mt.Route> routes}) {
  int angle = 0;

  /// Next bit of code is to try and compensate for tangential lead-ins and run-offs that distort
  /// the radially aligned direction change that a roundabout sign displays.
  /// It does it by getting the angle of approch and leave angle at the distance of 25 - 100 m from
  /// the roundabout. Should help in most cases, though very large roundabouts could still be an issue.
  /// The bearingBefore and bearingAfter is at the point of joining or leaving the actual roundabout.

  if (maneuvers[index].type.contains('roundabout')) {
    if (maneuvers[index].type == 'roundabout') {
      int distance = 0;
      PositionData positionData =
          getClosestPoint(routes: routes, position: maneuvers[index].location);

      LatLng point1 = LatLng(0, 0);
      LatLng point2 = LatLng(0, 0);
      LatLng point3 = LatLng(0, 0);
      LatLng point4 = LatLng(0, 0);

      for (int i = positionData.pointIndex; i > 0; i--) {
        distance = distanceBetween(maneuvers[index].location,
                routes[positionData.routeIndex].points[i],
                meters: true)
            .toInt();
        if (point2 == LatLng(0, 0) && distance > 25) {
          point2 = routes[positionData.routeIndex].points[i];
        } else if ((point1 == LatLng(0, 0) && distance > 100) || i == 0) {
          point1 = routes[positionData.routeIndex].points[i];
          break;
        }
      }

      positionData = getClosestPoint(
          routes: routes, position: maneuvers[index + 1].location);

      for (int i = positionData.pointIndex;
          i < routes[positionData.routeIndex].points.length;
          i++) {
        distance = distanceBetween(maneuvers[index + 1].location,
                routes[positionData.routeIndex].points[i],
                meters: true)
            .toInt();
        if (point3 == LatLng(0, 0) && distance > 25) {
          point3 = routes[positionData.routeIndex].points[i];
        } else if ((point4 == LatLng(0, 0) && distance > 100) || i == 0) {
          point4 = routes[positionData.routeIndex].points[i];
          break;
        }
      }

      int approachAngle = angleFromPoints(point1: point1, point2: point2);
      int leaveAngle = angleFromPoints(point1: point3, point2: point4);

      maneuvers[index].bearingBefore = approachAngle;
      maneuvers[index].bearingAfter = leaveAngle;

      /// Give the exit roundabout maneuver the same angles
      maneuvers[index + 1].bearingBefore = approachAngle;
      maneuvers[index + 1].bearingAfter = leaveAngle;

      // int deltaAngle = approachAngle - leaveAngle;
      // int summaryAngle = angleFromPoints(point1: point1, point2: point4);
      // leaveAngle = leaveAngle - approachAngle;

      ///   when the roundaboutPainter draws an arc it always starts at 3 O'Clock and paints clockwise
      ///   the painter describes all angles in radians but its angle parameter is degrees
      ///   the painter does the adjustment of the start from 3 O'Clock to 6 O'Clock
      ///   the painter adds the 180 degrees to represent straight on
      ///   the painter makes the adjustment from degrees to radians
      ///   approach angles will always be adjusted to N 0 degress
      ///   leave angles will adjusted to fit approach angles
      ///   the painter will be fed the arc in degrees to be transcribed from 6 O'Clock position
      ///
      ///   approach    exit     delta      painted arc (180 + delta)
      ///     |           |         0       180 degrees
      ///
      ///     |           /        45       225 degrees
      ///
      ///     |           \       -45       135 degrees
      ///
    }

    angle = maneuvers[index].bearingAfter - maneuvers[index].bearingBefore;
  }
  return angle;
}

// getClosestPoint({int route = 0, int point = 0, bool full = true}) {
PositionData getClosestPoint(
    {List<mt.Route> routes = const [],
    LatLng position = const LatLng(0, 0),
    int route = 0,
    int point = 0,
    bool full = true}) {
  PositionData positionData =
      PositionData(point, route, 9999999, 9999999, 99999999);
  int further = 0;
  for (int i = route; i < routes.length; i++) {
    for (int j = point; j < routes[i].points.length; j++) {
      double distance = Geolocator.distanceBetween(
          position.latitude,
          position.longitude,
          routes[i].points[j].latitude,
          routes[i].points[j].longitude);
      if (distance < positionData.metersToRoute) {
        positionData.routeIndex = i;
        positionData.pointIndex = j;
        positionData.metersToRoute = distance.toInt();
        full = distance < 10 ? false : full;
        further = 0;
      } else {
        if (further++ > 10 && !full) {
          break;
        }
      }
    }
  }
  positionData.metersToRoute =
      positionData.metersToRoute == 999999999 ? 0 : positionData.metersToRoute;
  return positionData;
}

int angleFromPoints({required LatLng point1, required LatLng point2}) {
  double lat1Rad = point1.latitude * (pi / 180);
  double lng1Rad = point1.longitude * (pi / 180);
  double lat2Rad = point2.latitude * (pi / 180);
  double lng2Rad = point2.longitude * (pi / 180);
  double avgLat = (lat1Rad + lat2Rad) / 2;
  double deltaLat = (lat2Rad - lat1Rad);
  double deltaLng = (lng2Rad - lng1Rad);
  double angleRad = atan2(deltaLng * cos(avgLat), deltaLat);
  return ((angleRad * 180 / pi + 360) % 360).toInt();
}

/// findManeuver finds the next / previous maneuver
///
int findManeuver(
    {required List<Maneuver> maneuvers,
    required LatLng position,
    currentIndex = 0,
    increment = 0}) {
  double distance = 0;
  int oldIndex = currentIndex;
  for (int i = 0; i < maneuvers.length; i++) {
    double delta = getDistance(
        maneuvers: maneuvers, position: position, index: currentIndex);
    if (distance > delta && i != currentIndex) {
      if (currentIndex > -1) {}
      currentIndex = i;
      distance = delta;
    }
  }
  if (oldIndex > -1 && increment == 0) {
    increment = currentIndex > oldIndex ? 1 : -1;
  }
  return currentIndex;
}

double getDistance(
    {required List<Maneuver> maneuvers,
    required LatLng position,
    int index = 0}) {
  if (index < maneuvers.length && index > -1) {
    return Geolocator.distanceBetween(
        position.latitude,
        position.longitude,
        maneuvers[index].location.latitude,
        maneuvers[index].location.longitude);
  }
  return 0;
}
